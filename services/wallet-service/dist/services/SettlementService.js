"use strict";
// services/wallet-service/src/services/SettlementService.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.SettlementService = void 0;
const client_1 = require("@prisma/client");
const prisma = new client_1.PrismaClient();
class SettlementService {
    /**
     * Process Game Settlement (Zero-Inflation Model)
     *
     * Flow:
     * 1. Debit all locked bets (Realize the Pot)
     * 2. Calculate Splits:
     *    - Null Amount = Pot * Null%
     *    - Winner Amount = Pot - Null Amount
     *    - Broker Commissions = Calculated from Null Amount (Revenue Share)
     *    - Net Panel Profit = Null Amount - Total Broker Commissions
     * 3. Credit Winner
     * 4. Credit Brokers (if any)
     * 5. Credit Panel Admin (Net Profit)
     */
    async settleRound(roundId, winnerId, playerIds, panelId, nullPercent, brokerCommissionRate // e.g., 0.10 for 10% of Null
    ) {
        return await prisma.$transaction(async (tx) => {
            // 1. Fetch Round & Locks
            const locks = await tx.walletLock.findMany({
                where: { roundId, isReleased: false },
                include: { wallet: true },
            });
            const totalPot = locks.reduce((sum, lock) => sum + Number(lock.amount), 0);
            // 2. Debit Locks (Realize Pot)
            for (const lock of locks) {
                // Unlock funds: lockedBalance -= amount, balance -= amount (since it's spent)
                // Wait! The standard model usually locks funds (balance remains same, available decreases).
                // When spent: lockedBalance -= amount, balance -= amount.
                await tx.wallet.update({
                    where: { id: lock.walletId },
                    data: {
                        lockedBalance: { decrement: lock.amount },
                        balance: { decrement: lock.amount },
                    },
                });
                await tx.walletLock.update({
                    where: { id: lock.id },
                    data: { isReleased: true, releasedAt: new Date() },
                });
            }
            // 3. Calculate Distribution
            const nullAmount = Math.floor(totalPot * (nullPercent / 100));
            const winnerAmount = totalPot - nullAmount;
            // 4. Broker Logic (Revenue Share from Null)
            // Assumption: Each player might have a broker. We distribute a share of the "Null" generated by that player's contribution?
            // Simplified Model: Panel pays a fixed % of Null to the Winner's Broker (or all brokers involved).
            // Let's assume we credit the Winner's Broker for simplicity in this iteration, 
            // OR iterate all players and pay their brokers based on their contribution.
            // Better: Fetch winner's broker.
            const winnerUser = await tx.user.findUnique({ where: { id: winnerId }, include: { broker: true } });
            const brokerCommissions = [];
            let totalBrokerCommission = 0;
            if (winnerUser?.brokerId) {
                const commission = Math.floor(nullAmount * brokerCommissionRate);
                if (commission > 0) {
                    brokerCommissions.push({ brokerId: winnerUser.brokerId, amount: commission });
                    totalBrokerCommission += commission;
                }
            }
            const netPanelProfit = nullAmount - totalBrokerCommission;
            // 5. Credit Winner
            const winnerWallet = await tx.wallet.update({
                where: { userId: winnerId },
                data: { balance: { increment: winnerAmount } },
            });
            await tx.ledgerEntry.create({
                data: {
                    walletId: winnerWallet.id,
                    type: client_1.LedgerEntryType.WIN,
                    amount: winnerAmount,
                    balanceAfter: winnerWallet.balance, // CORRECTED: Use updated balance
                    roundId,
                    metadata: { totalPot, nullAmount },
                },
            });
            // 6. Credit Brokers
            for (const comm of brokerCommissions) {
                // Find broker wallet
                const brokerWallet = await tx.wallet.findUnique({ where: { userId: comm.brokerId } });
                if (brokerWallet) {
                    const updatedBroker = await tx.wallet.update({
                        where: { id: brokerWallet.id },
                        data: { balance: { increment: comm.amount } },
                    });
                    await tx.ledgerEntry.create({
                        data: {
                            walletId: brokerWallet.id,
                            type: client_1.LedgerEntryType.BROKER_COMMISSION,
                            amount: comm.amount,
                            balanceAfter: updatedBroker.balance, // CORRECTED
                            roundId,
                            metadata: { source: 'round_revenue_share' },
                        },
                    });
                }
            }
            // 7. Credit Panel (Net Profit)
            // Assuming Panel has a 'Master Wallet' or just logging it. 
            // If Panel Admin is a User, credit them.
            const panelAdmin = await tx.user.findFirst({ where: { panelId, role: 'PANEL_ADMIN' } });
            if (panelAdmin) {
                const panelWallet = await tx.wallet.upsert({
                    where: { userId: panelAdmin.id },
                    create: { userId: panelAdmin.id },
                    update: { balance: { increment: netPanelProfit } },
                });
                await tx.ledgerEntry.create({
                    data: {
                        walletId: panelWallet.id,
                        type: client_1.LedgerEntryType.NULL_COMMISSION,
                        amount: netPanelProfit,
                        balanceAfter: panelWallet.balance, // CORRECTED
                        roundId,
                        metadata: { grossNull: nullAmount, brokerPaid: totalBrokerCommission },
                    },
                });
            }
            return {
                roundId,
                winnerId,
                totalPot,
                winnerAmount,
                nullAmount,
                brokerCommissions,
            };
        });
    }
}
exports.SettlementService = SettlementService;
