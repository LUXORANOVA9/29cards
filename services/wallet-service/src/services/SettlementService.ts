// services/wallet-service/src/services/SettlementService.ts

import { PrismaClient, LedgerEntryType } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';

const prisma = new PrismaClient();

export interface SettlementResult {
  roundId: string;
  winnerId: string;
  totalPot: number;
  winnerAmount: number;
  nullAmount: number;
  brokerCommissions: { brokerId: string; amount: number }[];
}

export class SettlementService {
  /**
   * Process Game Settlement (Zero-Inflation Model)
   * 
   * Flow:
   * 1. Debit all locked bets (Realize the Pot)
   * 2. Calculate Splits:
   *    - Null Amount = Pot * Null%
   *    - Winner Amount = Pot - Null Amount
   *    - Broker Commissions = Calculated from Null Amount (Revenue Share)
   *    - Net Panel Profit = Null Amount - Total Broker Commissions
   * 3. Credit Winner
   * 4. Credit Brokers (if any)
   * 5. Credit Panel Admin (Net Profit)
   */
  async settleRound(
    roundId: string,
    winnerId: string,
    playerIds: string[],
    panelId: string,
    nullPercent: number,
    brokerCommissionRate: number // e.g., 0.10 for 10% of Null
  ): Promise<SettlementResult> {
    return await prisma.$transaction(async (tx: any) => {
      // 1. Fetch Round & Locks
      const locks = await tx.walletLock.findMany({
        where: { roundId, isReleased: false },
        include: { wallet: true },
      });

      const totalPot = locks.reduce((sum: number, lock: any) => sum + Number(lock.amount), 0);

      // 2. Debit Locks (Realize Pot)
      for (const lock of locks) {
        // Unlock funds: lockedBalance -= amount, balance -= amount (since it's spent)
        // Wait! The standard model usually locks funds (balance remains same, available decreases).
        // When spent: lockedBalance -= amount, balance -= amount.

        await tx.wallet.update({
          where: { id: lock.walletId },
          data: {
            lockedBalance: { decrement: lock.amount },
            balance: { decrement: lock.amount },
          },
        });

        await tx.walletLock.update({
          where: { id: lock.id },
          data: { isReleased: true, releasedAt: new Date() },
        });
      }

      // 3. Calculate Distribution
      const nullAmount = Math.floor(totalPot * (nullPercent / 100));
      const winnerAmount = totalPot - nullAmount;

      // 4. Broker Logic (Revenue Share from Null)
      // Assumption: Each player might have a broker. We distribute a share of the "Null" generated by that player's contribution?
      // Simplified Model: Panel pays a fixed % of Null to the Winner's Broker (or all brokers involved).
      // Let's assume we credit the Winner's Broker for simplicity in this iteration, 
      // OR iterate all players and pay their brokers based on their contribution.
      // Better: Fetch winner's broker.
      const winnerUser = await tx.user.findUnique({ where: { id: winnerId }, include: { broker: true } });
      const brokerCommissions: { brokerId: string; amount: number }[] = [];
      let totalBrokerCommission = 0;

      if (winnerUser?.brokerId) {
        const commission = Math.floor(nullAmount * brokerCommissionRate);
        if (commission > 0) {
          brokerCommissions.push({ brokerId: winnerUser.brokerId, amount: commission });
          totalBrokerCommission += commission;
        }
      }

      const netPanelProfit = nullAmount - totalBrokerCommission;

      // 5. Credit Winner
      const winnerWallet = await tx.wallet.update({
        where: { userId: winnerId },
        data: { balance: { increment: winnerAmount } },
      });

      await tx.ledgerEntry.create({
        data: {
          walletId: winnerWallet.id,
          type: LedgerEntryType.WIN,
          amount: winnerAmount,
          balanceAfter: winnerWallet.balance, // CORRECTED: Use updated balance
          roundId,
          metadata: { totalPot, nullAmount },
        },
      });

      // 6. Credit Brokers
      for (const comm of brokerCommissions) {
        // Find broker wallet
        const brokerWallet = await tx.wallet.findUnique({ where: { userId: comm.brokerId } });
        if (brokerWallet) {
          const updatedBroker = await tx.wallet.update({
            where: { id: brokerWallet.id },
            data: { balance: { increment: comm.amount } },
          });

          await tx.ledgerEntry.create({
            data: {
              walletId: brokerWallet.id,
              type: LedgerEntryType.BROKER_COMMISSION,
              amount: comm.amount,
              balanceAfter: updatedBroker.balance, // CORRECTED
              roundId,
              metadata: { source: 'round_revenue_share' },
            },
          });
        }
      }

      // 7. Credit Panel (Net Profit)
      // Assuming Panel has a 'Master Wallet' or just logging it. 
      // If Panel Admin is a User, credit them.
      const panelAdmin = await tx.user.findFirst({ where: { panelId, role: 'PANEL_ADMIN' } });
      if (panelAdmin) {
        const panelWallet = await tx.wallet.upsert({
          where: { userId: panelAdmin.id },
          create: { userId: panelAdmin.id },
          update: { balance: { increment: netPanelProfit } },
        });

        await tx.ledgerEntry.create({
          data: {
            walletId: panelWallet.id,
            type: LedgerEntryType.NULL_COMMISSION,
            amount: netPanelProfit,
            balanceAfter: panelWallet.balance, // CORRECTED
            roundId,
            metadata: { grossNull: nullAmount, brokerPaid: totalBrokerCommission },
          },
        });
      }

      return {
        roundId,
        winnerId,
        totalPot,
        winnerAmount,
        nullAmount,
        brokerCommissions,
      };
    });
  }
}
